#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <xmc_scu.h>
#include "Driver_USART.h"
#include "xmc_uart.h"
#include "Board_LED.h"
#include "XMC1000_TSE.h"
#include "arm_math.h"
#include "math_helper.h"

#define TEST_RUN_N	200

/* USART Driver */
extern ARM_DRIVER_USART Driver_USART0;
static ARM_DRIVER_USART *UARTdrv = &Driver_USART0; 
__IO uint32_t g_Ticks;

#define PTS_NUM	9424
/*------------------------------------------------------------------------------
*  External table used for linear interpolation
*------------------------------------------------------------------------------*/
extern const float arm_linear_interep_table[PTS_NUM];

void myUART_callback(uint32_t event)
{
    switch (event)
    {
    case ARM_USART_EVENT_RECEIVE_COMPLETE:  
//     if (cmd == 0x0D)        /* Send back the message if Enter is recived*/
//     {
//       UARTdrv->Send("\nHello World!\r\n", 15);
//       cmd = 0;   
//       UARTdrv->Receive(&cmd, 1);
//     }
     break;
     
    case ARM_USART_EVENT_TRANSFER_COMPLETE:
    case ARM_USART_EVENT_SEND_COMPLETE:
    case ARM_USART_EVENT_TX_COMPLETE:
        break;
 
    case ARM_USART_EVENT_RX_TIMEOUT:
//         __breakpoint(0);  /* Error: Call debugger or replace with custom error handling */
        break;
 
    case ARM_USART_EVENT_RX_OVERFLOW:
    case ARM_USART_EVENT_TX_UNDERFLOW:
		default:
//        __breakpoint(0);  /* Error: Call debugger or replace with custom error handling */
        break;
    }
}
  
int stdout_putchar (int ch)
{
//	UARTdrv->Send();
	XMC_UART_CH_Transmit(XMC_UART0_CH0, ch);
	return ch;
}

void SysTick_Handler(void)
{
  g_Ticks++;
}     


#define SNR_THRESHOLD           90
#define TEST_LENGTH_SAMPLES     10
#define XSPACING	0.001
/* ----------------------------------------------------------------------
* Test input data for F32 SIN function
* Generated by the MATLAB rand() function
* randn('state', 0)
* xi = (((1/4.18318581819710)* randn(blockSize, 1) * 2* pi));
* --------------------------------------------------------------------*/
float32_t testInputSin_f32[TEST_LENGTH_SAMPLES] =
{
   -0.649716504673081170, -2.501723745497831200,
    0.188250329003310100,  0.432092748487532540,
   -1.722010988459680800,  1.788766476323060600,
    1.786136060975809500, -0.056525543169408797,
    0.491596272728153760,  0.262309671126153390
};

/*------------------------------------------------------------------------------
*  Reference out of SIN F32 function for Block Size = 10
*  Calculated from sin(testInputSin_f32)
*------------------------------------------------------------------------------*/
float32_t testRefSinOutput32_f32[TEST_LENGTH_SAMPLES] =
{
   -0.604960695383043530, -0.597090287967934840,
    0.187140422442966500,  0.418772124875992690,
   -0.988588831792106880,  0.976338412038794010,
    0.976903856413481100, -0.056495446835214236,
    0.472033731854734240,  0.259311907228582830
};

/*------------------------------------------------------------------------------
*  Method 1: Test out Buffer Calculated from Cubic Interpolation
*------------------------------------------------------------------------------*/
volatile float32_t testOutput[TEST_LENGTH_SAMPLES];

/*------------------------------------------------------------------------------
*  Method 2: Test out buffer Calculated from Linear Interpolation
*------------------------------------------------------------------------------*/
volatile float32_t testLinIntOutput[TEST_LENGTH_SAMPLES];

/*------------------------------------------------------------------------------
*  Method 3: Test out Calculated from CLib sin function
*------------------------------------------------------------------------------*/
volatile float32_t testCLibOutput[TEST_LENGTH_SAMPLES];
/* ----------------------------------------------------------------------
* Global Variables for caluclating SNR's for Method1 & Method 2 & Method 3
* ------------------------------------------------------------------- */
float32_t snr1;
float32_t snr2;
float32_t snr3;

int main(void)
{
	uint32_t lockTick;
	uint32_t deltaTick;
	uint32_t temp_k=0;
	uint32_t temp_C=0;
	bool testRes;
  uint32_t i;
  arm_status status;

  arm_linear_interp_instance_f32 S = {PTS_NUM, -3.141592653589793238, XSPACING, (float32_t*)&arm_linear_interep_table[0]};
	
	/* Enable DTS */
	XMC_SCU_StartTempMeasurement();
	
  /* System timer configuration */
  SysTick_Config(SystemCoreClock / 1000);
	
  /*Initialize the UART driver */
  UARTdrv->Initialize(myUART_callback);
  /*Power up the UART peripheral */
  UARTdrv->PowerControl(ARM_POWER_FULL);
  /*Configure the USART to 9600 Bits/sec */
  UARTdrv->Control(ARM_USART_MODE_ASYNCHRONOUS |
                   ARM_USART_DATA_BITS_8 |
                   ARM_USART_PARITY_NONE |
                   ARM_USART_STOP_BITS_1 , 256000);
   
  /* Enable the Transmitter/Receiver line */
  UARTdrv->Control (ARM_USART_CONTROL_TX, 1);
  UARTdrv->Control (ARM_USART_CONTROL_RX, 1);
	  
	LED_Initialize();
	
	printf("Linear Interp example 2Go Board @%u Hz\n",SystemCoreClock	);
	

  /*------------------------------------------------------------------------------
  *  Method 1: Test out Calculated from Cubic Interpolation
  *------------------------------------------------------------------------------*/
	deltaTick = g_Ticks;
	//Loop for performance profile
	for(uint16_t test_cnt = 0; test_cnt<TEST_RUN_N; ++test_cnt)
	{
		for(i=0; i< TEST_LENGTH_SAMPLES; i++)
		{
			testOutput[i] = arm_sin_f32(testInputSin_f32[i]);
		}
	}
	deltaTick = g_Ticks - deltaTick;
	printf("Method 1: Test out Calculated from Cubic Interpolation\nResult:\n");
//  for(i=0; i< TEST_LENGTH_SAMPLES; i++)
//  {
//    printf("%f\t", testOutput[i]);
//  }
  snr1 = arm_snr_f32(testRefSinOutput32_f32, testOutput, 2);
	printf("Ticks:%u, SNR:%f\n\n", deltaTick, snr1);
  /*------------------------------------------------------------------------------
  *  Method 2: Test out Calculated from Cubic Interpolation and Linear interpolation
  *------------------------------------------------------------------------------*/
	deltaTick = g_Ticks;
	//Loop for performance profile
	for(uint16_t test_cnt = 0; test_cnt<TEST_RUN_N; ++test_cnt)
	{	
		for(i=0; i< TEST_LENGTH_SAMPLES; i++)
		{
				testLinIntOutput[i] = arm_linear_interp_f32(&S, testInputSin_f32[i]);
		}
	}
	deltaTick = g_Ticks - deltaTick;
	printf(" Method 2: Test out Calculated from Cubic Interpolation and Linear interpolation\nResult:\n");
//  for(i=0; i< TEST_LENGTH_SAMPLES; i++)
//  {
//    printf("%f\t", testLinIntOutput[i]);
//  }
  snr2 = arm_snr_f32(testRefSinOutput32_f32, testLinIntOutput, 2);
	printf("Ticks:%u, SNR:%f\n\n", deltaTick, snr2);
	
  /*------------------------------------------------------------------------------
  *  Method 3: Test out Calculated from CLib sin function
  *------------------------------------------------------------------------------*/
	deltaTick = g_Ticks;
	//Loop for performance profile
	for(uint16_t test_cnt = 0; test_cnt<TEST_RUN_N; ++test_cnt)
	{	
		for(i=0; i< TEST_LENGTH_SAMPLES; i++)
		{
				testCLibOutput[i] = sin(testInputSin_f32[i]);
		}
	}
	deltaTick = g_Ticks - deltaTick;
	printf(" Method 3: Test out Calculated from CLib sin function\nResult:\n");
//  for(i=0; i< TEST_LENGTH_SAMPLES; i++)
//  {
//    printf("%f\t", testCLibOutput[i]);
//  }
  snr3 = arm_snr_f32(testRefSinOutput32_f32, testCLibOutput, 2);
	printf("Ticks:%u, SNR:%f\n\n", deltaTick, snr3);

  /*------------------------------------------------------------------------------
  *            Initialise status depending on SNR calculations
  *------------------------------------------------------------------------------*/
  if( snr2 > snr1)
  {
    status = ARM_MATH_SUCCESS;
  }
  else
  {
    status = ARM_MATH_TEST_FAILURE;
  }
		
	while (1)
  {
		/* Calculate temperature of the chip in Kelvin */
		temp_k = XMC1000_CalcTemperature();

		/* Convert temperature to Celcius */
		temp_C = temp_k - 273;

//		printf("%u %f %f %f\tTSE_I=%u 'C\n", status, snr1, snr2, snr3, temp_C);
				
    LED_On(0);
    LED_On(1);
		
		lockTick = g_Ticks;
		while((lockTick+4000) > g_Ticks)
		{
			__NOP();
			__WFI();
		}
		
    LED_Off(0);
    LED_Off(1);
		
		lockTick = g_Ticks;
		while((lockTick+4000) > g_Ticks)
		{
			__NOP();
			__WFI();
		}		
  }
}
